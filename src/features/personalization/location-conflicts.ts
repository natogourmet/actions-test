import { hideTooltip, showTooltip } from '@/components/tooltip';
import { ConfigureUI } from '@/configure/ConfigureUI';
import { sleep } from '@/configure/utils/general';
import { interpolate } from '@/configure/utils/text';
import { t } from '@/i18n';
import { ValueAssociationManager } from './ValueAssociationManager';

/** Key of the Metadata entry that specifies the conflicts */
const METADATA_KEY = 'conflicts_with';
/** Character used to separate the different AVs in the metadata entry */
const SEPARATOR = '|';
/** AV property used in the metadata entry as Id */
const AV_PROPERTY = 'vendorId';

/* CSS Selector for the Swatch Div  */
const SWATCH_DIV_SELECTOR = '.fc-swatch-ca';
/* CSS Selector template to find a specific AV swatch (and exclude from certain CA) */
const SWATCH_SELECTOR_SPECIFIC_AV_TEMPLATE = SWATCH_DIV_SELECTOR + '.fc-swatch-av-{av}:not(.fc-swatch-ca-{ca})';

/** Class used to disable the swatch */
const LOCATION_DISABLED_CLASS = 'fc-adi-location-disabled';

/** List of Abort Controllers that allow to remove the event listeners when not needed anymore */
const abortControllers: AbortController[] = [];

/**
 * Implements the "location conflict" feature.
 *
 * This feature allows to disable certain location AVs in the UI when they would overlap with others already selected.
 *
 * For example, the team name, logo or player number can be located in the center, but only one at a time.
 *
 * Each AV contains a list of other AVs it conflicts with, so that list is processed and when that AV is selected, the other
 * AVs get disabled.
 *
 * The UI is disabled by using a class that makes it black and white, reduces opacity and disables pointer interaction.
 *
 * Also, a tooltip is created for each disabled swatch, indicating why it is disabled
 *
 * @param configure ConfigureUI instance
 */
export function implementLocationConflicts(configure: ConfigureUI): void {
  // Creates the Value association manager
  const manager = new ValueAssociationManager(configure, {
    metadataKey: METADATA_KEY,
    listSeparator: SEPARATOR,
    avProperty: AV_PROPERTY
  });

  // Stores the currently active CA, so we can update its swatches on media query change
  let activeCAId: number = -1;

  // Creates a map that associates a CA Id (location) with the Parent CA name (Player name, Team name, Player number, etc)
  // Used to show which CA is disabling a location
  const parentCaMap = buildParentNameMap();

  // Listen to when the list of selected AVs (with conflicts) is updated
  manager.addEventListener('update:selected', updateSwatchesUI);

  // When a CA becomes active in the UI (accordion or pager), the appropiate swatches need to be disabled according
  // to the current state
  configure.on('ca:focus', (data) => onCAFocus(data.caId));

  configure.on('mediaQuery:change', () => {
    // If there's an active CA, update its swatches
    if (activeCAId !== -1) onCAFocus(activeCAId);
  });

  function buildParentNameMap() {
    const product = configure.getProduct();
    if (!product) return {};

    const result: Record<number, string> = {};
    // Get all the location CAs with conflicts
    const cas = product.attributes.flatMap((ca) => manager.getCAsWithAssociations(ca));

    // Associate the CA Id with its parent CA's name.
    for (const ca of cas) {
      const parentCA = ca.parentId ? configure.getAttribute({ id: ca.parentId }) : undefined;
      if (parentCA) result[ca.id] = parentCA.name;
    }
    return result;
  }

  /**
   * When a CA is focused on the UI, the DOM is regenerated by React.
   * So we need to wait until it's finished and disable the appropiate swatches
   * @param caId id of the focused CA
   */
  async function onCAFocus(caId: number): Promise<void> {
    activeCAId = caId;

    // Get the CA
    const ca = configure.getAttribute({ id: caId });
    if (!ca) return;

    // From the focused CA, get the list of CAs with conflicts (it may contain multiple sub CAs)
    // It's usually only one CA (eg. the location)
    const cas = manager.getCAsWithAssociations(ca);

    // Wait for React to render the UI so we can manipulate the resulting DOM
    await sleep(0);

    // The event listeners for the focused CAs will be recreated, so remove the ones we already have
    removeAllEventListeners();

    // For each value in the CAs (eg. the locations)
    for (const ca of cas) {
      for (const av of ca.values) {
        // If the value is not conflicting with the current selections, do nothing
        if (!manager.selectionAssociatedAVs.has(av.vendorId)) continue;

        // The value is conflicting with a selected location, so we need to disable it UNLESS they both belong to the same CA
        // (AVs shouldn't disable other AVs in the same CA)
        // So we must iterate each selected {ca, av} to check
        for (const recipeItem of manager.selectedAttributeValuePairs) {
          // If the CA is the same, do not disable it
          if (recipeItem.ca === ca.id) continue;

          // At this point, the CA is different, so if the value is in conflict with one selected, disable it
          if (manager.associationMap[recipeItem.av].includes(av.vendorId)) {
            updateSwatch(av.vendorId, recipeItem.ca);
          }
        }
      }
    }
  }

  /**
   * Updates all the swatches using the full recipe. Overwrites the current state.
   *
   * First it removes the "disabled" class and tooltip event listeners from all swatches
   * and then adds it to the ones that should be disabled
   */
  async function updateSwatchesUI() {
    // We need to wait for the swatches to be created by React
    await sleep(0);

    // All the event listeners will be recreated, so remove the ones we already have
    removeAllEventListeners();

    // Clear "disabled" on all swatches
    document
      .querySelectorAll(SWATCH_DIV_SELECTOR + '.' + LOCATION_DISABLED_CLASS)
      .forEach((el) => el.classList.remove(LOCATION_DISABLED_CLASS));

    // Iterate the selected {ca,av} pairs and disable all conflicting values (excluding the ones from the same CA)
    manager.selectedAttributeValuePairs.forEach(({ ca, av }) => {
      manager.associationMap[av].forEach((value) => updateSwatch(value, ca));
    });
  }

  /**
   * Add the "disabled" class to the swatches that belong to AVs with the specified vendorId,
   * **excluding** the ones from the provided CA.
   *
   * @param avVendorId vendor ID of the AVs to disable
   * @param excludeCAId id of the CA to exclude in the search
   */
  function updateSwatch(avVendorId: string, excludeCAId: number): void {
    const selector = interpolate(SWATCH_SELECTOR_SPECIFIC_AV_TEMPLATE, {
      av: avVendorId.replaceAll('_', '-'),
      ca: excludeCAId.toString()
    });
    const elements = document.querySelectorAll(selector);

    // Elements not found, probably not created by React yet
    if (elements.length === 0) {
      console.log('[Location Conflicts] Tried disabling Location %s, but swatch was not found on the DOM', avVendorId);
      return;
    }

    console.log('[Location Conflicts] Disabling Location %s (%d found)', avVendorId, elements.length);

    // Cache content of the tooltip
    const content = ConflictTooltip(parentCaMap[excludeCAId]);

    elements.forEach((el) => {
      // Disables the swatch by adding the appropiate class
      el.classList.add(LOCATION_DISABLED_CLASS);

      // Adds tooltip
      addTooltip(el, content);
    });
  }

  function addTooltip(el: Element, content: string) {
    // Create the Abort Controller
    const abortCtrl = new AbortController();
    abortControllers.push(abortCtrl);

    // Add tooltip on mouseover/touchstart
    ['mouseover', 'touchstart'].forEach((eventName) =>
      el.addEventListener(eventName, ({ target }) => showTooltip({ target, content }), { signal: abortCtrl.signal })
    );

    // Remove tooltip on mouseleave/touchend (touchend waits for tooltip to be created)
    el.addEventListener('mouseleave', hideTooltip, { signal: abortCtrl.signal });
    el.addEventListener('touchend', () => sleep(0).then(hideTooltip), { signal: abortCtrl.signal });
  }

  /**
   * Removes all events listeners and clean the controllers array
   */
  function removeAllEventListeners() {
    abortControllers.forEach((c) => c.abort());
    abortControllers.splice(0, abortControllers.length);
  }
}

/**
 * HTML for the Conflict tooltip
 */
function ConflictTooltip(caName: string) {
  return /* html */ `
   <div class="fc-swatch-tooltip-inner">
    <div class="fc-swatch-tooltip-name">
      ${t('pp_location_conflict', { ca: caName })}
    </div>
  </div>
  `;
}
